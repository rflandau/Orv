syntax = "proto3";

package orv;

import "slims/pb/message_types.proto";

option go_package = "github.com/rflandau/Orv/implementations/slims/orv/pb/";

// generate with:
// protoc --go_out=. --go_opt=paths=source_relative orv/pb/payloads.proto

// Type #1
// Negative response to any packet.
message Fault {
  // uint16 | echos the type number of the original packet
  msg.MessageType original = 1;

  enum Errnos {
    // implementation-specific error, the equivalent of a 500 Internal
    // Server Error. Should be used as sparingly as possible.
    UNSPECIFIED = 000;
    UNKNOWN_TYPE = 001; // sent when an unknown message type number is declared.
    BODY_NOT_ACCEPTED = 002;
    BODY_REQUIRED = 003;
    SHORTHAND_NOT_ACCEPTED = 004;
    VERSION_NOT_SUPPORTED = 005;
    MALFORMED_BODY = 006;
    MALFORMED_ADDRESS = 007;

    // JOIN

    HELLO_REQUIRED = 400;
    BAD_HEIGHT = 401;
    ID_IN_USE = 402;

    // REGISTER

    BAD_SERVICE_NAME = 600;
    BAD_STALE_TIME = 601;
    UNKNOWN_CHILD_ID = 602;
  }

  // uint16 | the type of error, for automated testing.
  // should be one of the above enums
  Errnos errno = 2;
  optional string additional_info = 3; // (OPTIONAL)
}

// Type #2
// Initial greeting.
// Requiring prior to other, non-client-request packet chains.
message Hello {}

// Type #3
// Response to a HELLO request.
message HelloAck {
  uint32 height = 1; // uint16
}

// Type #4
// Requesting to join a vault.
message Join {
  // is the node requesting to join the vault a VK?
  bool is_vk = 1;
  // required iff isVK | address at which the VK can receive requests/INCREMENTs
  string vk_addr = 2;
  // uint16 | required iff isVK | height of the requestor node
  uint32 height = 3;
}

// Type #5
// VK accepting the requestor to join underneath it.
// Once received, requestor can safely mark the VK as its parent.
message JoinAccept {
  // uint16 | height of the accepting vk
  uint32 height = 1;
}

// Type #6
// Sent by children to register a service to their parent.
message Register {
  string service = 1; // name of the service to be registered
  string address = 2; // the address at which the service can be accessed
  // Go time string declaring how long
  // (w/o a heartbeat) until this service is considered prune-able
  string stale = 3;
}

// Type #7
message RegisterAccept {
  // name of the service that was registered
  string service = 1;
}

// Type #12
message ServiceHeartbeat {
  // name of the service that was registered
  repeated string services = 1;
}

// Type #13
message ServiceHeartbeatAck {
  // name of the services that were refreshed
  repeated string refresheds = 1;
  // name of services that were requested to be refreshed, but are unknown
  repeated string unknowns = 2;
}

//#region client requests

// Response to a STATUS request
message StatusResp {
  // uint16
  uint32 height = 1;
  // packed bytes; MSN is major, LSN is minor
  bytes versions_supported = 2;
}

// Type #18
message List {
  // uint16 | number of nodes to traverse (limited by root height)
  uint32 hop_limit = 1;
}

// Type #19
message ListResp {
  // list of services known to the responding vk
  repeated string services = 1;
}

// Type #20
message Get {
  string service = 1;   //  the name of the desired service
  uint32 hop_limit = 2; // uint16
  // identifier created by the requestor so it can correlate a valid response
  uint64 token = 3;
}

// Type #21
message GetResp {
  uint64 host_id = 1;
  string service = 2;
  string address = 3;
  // echo of the token created by the requestor
  uint64 token = 4;
}
//#endregion client requests
